#! /bin/bash

declare -a serv_pathes=("DVA" "INV/inventory" "USR/account" "BKS/backstage" "PUR/purchase" "API/api")
declare -a serv_names=("DVA" "INV" "USR" "BKS" "PUR" "API")
declare -a script_names=("./diva" "./dev" "./dev" "./dev" "./dev" "./dev")
declare -a add_options
add_options[0]=""                                                            # DVA
add_options[1]="export JAVA_OPTS='-Xms512M -Xmx3072M -XX:MaxPermSize=1024M'" # INV
add_options[2]="export JAVA_OPTS='-Xms512M -Xmx3072M -XX:MaxPermSize=1024M'" # USR
add_options[3]="export JAVA_OPTS='-Xms512M -Xmx3072M -XX:MaxPermSize=1024M'" # BKS
add_options[4]="export JAVA_OPTS='-Xms512M -Xmx3072M -XX:MaxPermSize=1024M'" # PUR
add_options[4]=""                                                            # API

########### Don't change below it ##############

function val_of_keyword {
    sys_IFS=${IFS}
    IFS=' ' read -a set_of_keys <<< "$1"

    for item in "${set_of_keys[@]}"; do
        keyword=`echo $item | cut -d '=' -f 1`
       
        if [ "${keyword}" == "${2}" ]; then
            echo ${item} | cut -d '=' -f 2 | sed -e 's/\"//g'
            IFS=${sys_IFS}
            return
        fi 
    done
}

function brackets_content {
    cont=$(echo ${1} | sed -e "s/.*${2}{//")
    level=1
    len_of_cont=${#cont}
    result=''
    
    for (( idx=0; idx<len_of_cont; idx++ )); do
        symbol=${cont:idx:1}
        
        case ${symbol} in
            '{' )
                if [ "${level}" -gt "0" ]; then
                    result=${result}${symbol}
                fi
                level=`expr ${level} + 1`                
                ;;
            '}' )
                level=`expr ${level} - 1`
                if [ "${level}" -gt "0" ]; then
                    result=${result}${symbol}
                else
                    break
                fi
                ;;
            * )
                if [ "${level}" -gt "0" ]; then
                    result=${result}${symbol}
                fi
                ;;
        esac
    done

    echo ${result}
}

function launch_service
{
    date_serv_start=`date +%s`
    chmod 777 "${1}"
    echo "" > "${2}"

    xterm -e "${1}" &
    xterm_service_pid=$!

    srv_pid=0
    service_status='starts'
    while [[ "${service_status}" = "starts" ]]; do
        if grep -i "server running" "${2}" >/dev/null 2>&1; then
            service_status="success"
            srv_pid=${xterm_service_pid}
            break
        fi
        if ! kill -0 $xterm_service_pid >/dev/null 2>&1; then
            service_status="error"
            echo -e "\nERROR: ${3} could not start. You can see all it's console messages in ${2}"
            srv_pid=0
            break
        fi
        echo -n '.'
        sleep 5
    done

    if [[ "${service_status}" = "success" ]]; then
        date_serv_end=`date +%s`
        different=`expr $date_serv_end - $date_serv_start`
        minutes=`expr $different / 60`
        seconds=`expr $different % 60`  
        printf "\n${3} successfully launched (PID=${srv_pid}). It took %02u:%02u (min:sec) \n\n" $minutes $seconds
    fi

    echo "${srv_pid}" > ${4}
}

current_dir="$(pwd)"
starter_prefix="tfly_starter_"
service_status='success'
declare -a pids

cur_user=$(whoami)

# Determine a "root" directory
this_source="${BASH_SOURCE[0]}"
while [ -h "${this_source}" ]; do # resolve $this_source until the file is no longer a symlink
  root_dir="$( cd -P "$( dirname "${this_source}" )" && pwd )"
  this_source="$(readlink "${this_source}")"

  # if ${this_source} was a relative symlink, we need to resolve it relative 
  # to the path where the symlink file was located
  [[ ${this_source} != /* ]] && this_source="$DIR/${this_source}" 
done

tfly_starter_dir="$( cd -P "$( dirname "${this_source}" )" && pwd )"
root_dir=$( echo ${tfly_starter_dir} | sed 's/\(.*\)\/\(.*\)/\1/' ) # remove a last part of the path ("/tfly_starter")
tmp_dir="${tfly_starter_dir}/tmp"
logs_dir="${tfly_starter_dir}/logs"
home_dir="/home/${cur_user}"
gvm_settings_path="${home_dir}/.gvm/bin/gvm-init.sh"

cd ${root_dir}

mkdir -p "${tfly_starter_dir}/logs"
mkdir -p "${tmp_dir}"

num_of_servs=${#serv_pathes[*]}

declare -i max_index
while true; do
    indx=0
    list_of_serv=''

    clear
    echo 'Please select which set of services you want to run:'
    while [[ $indx -lt $num_of_servs ]]; do
        [[ -n "${list_of_serv}" ]] && list_of_serv="$list_of_serv + "
        list_of_serv="${list_of_serv}${serv_names[${indx}]}"
        label=`expr ${indx} + 1`
        echo "${label}: ${list_of_serv}"
        indx=`expr ${indx} + 1`
    done

    read -p "Please enter 1..${num_of_servs} " -n 1 -s max_ind_of_serv
    echo

    max_index=${max_ind_of_serv}
    [[ "$max_index" -gt "0" ]] && [[ "$max_index" -le "$num_of_servs" ]] && break
done

echo ""
echo "OK, I'm trying to start ${max_index} services"
echo ""

date_start=`date +%s`

indx=0
while [[ $indx -lt $max_index ]]; do

    srv_path="${serv_pathes[${indx}]}"
    srv_name="${serv_names[${indx}]}"
    script_name="${script_names[${indx}]}"
    add_opts="${add_options[${indx}]}"

    echo -n "${srv_name} starts. Please wait "

    #
    # parse parameters and prepare service starter script
    #
    grails_version="DEFAULT"
    app_props_filename="${root_dir}/${srv_path}/application.properties"
    if [ -s ${app_props_filename} ]; then
	 while read line; do
            gr_vers=$(echo ${line} | sed -n '/grails.version.*/p' | cut --delimiter='=' --fields=2)
            [[ -n "${gr_vers}" ]] && grails_version=$gr_vers
	 done < "${root_dir}/${srv_path}/application.properties"
    fi

    starter_filename="${tmp_dir}/${starter_prefix}${srv_name}"
    pid_filename="${tmp_dir}/PID.txt"
    log_filename="${logs_dir}/${srv_name}.log"
    serv_dir="${root_dir}/${srv_path}"
    liquibase_dir="${tfly_starter_dir}/liquibase"
    grails_app_dir="${serv_dir}/grails-app"
    migrations_dir="${grails_app_dir}/migrations"
    data_source_groovy="${grails_app_dir}/conf/DataSource.groovy"

    echo "#! /bin/bash" > "${starter_filename}"
    
    if [ -d "${migrations_dir}" ] && [ -f "${data_source_groovy}" ]; then
        while read config; do
            conf="${conf}$(echo -e "${config}" | tr -d '[[:space:]]')" # strip all spaces
            conf="${conf} " # add single space after the end of each line
        done < "${data_source_groovy}"

        conf=`brackets_content "${conf}" "environments"` 
        conf=`brackets_content "${conf}" "development"`
        conf=`brackets_content "${conf}" "dataSource"`

        db_url=`val_of_keyword "${conf}" "url"`
        db_username=`val_of_keyword "${conf}" "username"`
        db_password=`val_of_keyword "${conf}" "password"`

        if [ -n "${db_url}" -a -n "${db_username}" -a -n "${db_password}" ]; then
            echo "echo '========== liquibase attempts to perform all migrations ========='" >> "${starter_filename}"
            echo "cd ${liquibase_dir}" >> "${starter_filename}"
            echo -n "java -jar './liquibase.jar' " >> "${starter_filename}"
            echo -n "--changeLogFile='${migrations_dir}/changelog.xml' " >> "${starter_filename}"
            echo -n "--username='${db_username}' " >> "${starter_filename}"
            echo -n "--password='${db_password}' " >> "${starter_filename}"
            echo -n "--url='${db_url}' " >> "${starter_filename}"
            echo "--classpath='${migrations_dir}:mysql-connector-java-5.1.34-bin.jar' update" >> "${starter_filename}"
        else 
            echo "echo '========== ERROR: liquibase not found an authentication data! ========='" >> "${starter_filename}"
        fi
    else
        if [ ${srv_name} != "DVA" ]; then
            echo "echo '========== ERROR: not found migrations dir or DataSource.groovy for liquibase! ========='" >> "${starter_filename}"
        fi
    fi

    echo "cd ${serv_dir}" >> "${starter_filename}"
    echo "${add_opts}" >> "${starter_filename}"
    if [ ${grails_version} != "DEFAULT" ]; then
	echo "[[ -s \"${gvm_settings_path}\" ]] && source \"${gvm_settings_path}\" " >> "${starter_filename}"
	echo "gvm use grails ${grails_version}" >> "${starter_filename}"
    fi
    if [ -f "${serv_dir}/grails-app/conf/BuildConfig.groovy" ]; then
        echo "grails refresh-dependencies" >> "${starter_filename}"
    fi

    input_val=""
    if [ ${srv_name} == "DVA" ]; then
        input_val='echo -e "project core\nliquibase-update\nproject server\nrun\n" | '
    fi

    echo "${input_val}${script_name} | tee -a ${log_filename}" >> "${starter_filename}"

    launch_service "${starter_filename}" "${log_filename}" "${srv_name}" "${pid_filename}"
    srv_pid=`cat "${pid_filename}"`

    if [[ "${srv_pid}" -gt "0" ]]; then
        pids[${indx}]=${srv_pid}
        indx=`expr ${indx} + 1`
    else
        pids[${indx}]=0
        break
    fi

done

if [[ $indx -eq $max_index ]]; then
    date_end=`date +%s`
    different=`expr $date_end - $date_start`
    minutes=`expr $different / 60`
    seconds=`expr $different % 60`
 
    printf "All requested services started. It took %02u:%02u (min:sec) \n\n" $minutes $seconds
fi

read -p "Please press any key for switching to the watchdog mode" -n 1 -s any_key

# stop / restart some services
num_of_servs=${#serv_pathes[*]}
declare -i serv_index
refresh_interval=5

while true; do
    clear
    echo "     --- "`date +%H:%M:%S`" ---"
    mon_text="Currently running (data is updated every $refresh_interval seconds): "
    for (( idx=0; idx<${num_of_servs}; idx++ )); do
        s_pid=${pids[idx]}
        if [ -n "${s_pid}" ] && [ "${s_pid}" -gt "0" ] && kill -0 ${s_pid} >/dev/null 2>&1; then
            mon_text="$mon_text ${serv_names[${idx}]}"
        fi
    done
    echo -e $mon_text"\n"

    indx=0
    echo 'Please select which services you want to stop or start/restart:'
    while [[ $indx -lt $num_of_servs ]]; do
        echo "${indx}: ${serv_names[${indx}]}"
        indx=`expr ${indx} + 1`
    done
    echo -e "${num_of_servs}: Stop all services and terminate this script\n "

    read -p "Please enter 0..${num_of_servs} " -t ${refresh_interval} -n 1 -s indx_of_action
    if [ -n "${indx_of_action}" ]; then
        serv_index=${indx_of_action}
        if [ "${serv_index}" -lt "${num_of_servs}" ]; then # processing one service
            srvc_pid=${pids[${serv_index}]}
            srv_name=${serv_names[${serv_index}]}

            if [ -n "${srvc_pid}" ] && [ "${srvc_pid}" -gt "0" ]; then # if service is running
                clear
                echo "${srv_name} is currently running. Please select:"
                echo "1 - stop it"
                echo "2 - restart it"
                echo "any other key - nothing"
                read -n 1 -s action 
                if [[ "${action}" = "1" ]] || [[ "${action}" = "2" ]]; then
                    echo "trying to terminate process..."
                    kill -INT ${srvc_pid}
                    while kill -0 ${srvc_pid} >/dev/null 2>&1; do
                        sleep 2
                    done
                    pids[${serv_index}]="0"
                    if [[ "${action}" = "2" ]]; then
                        echo "trying to start process..."
                        starter_filename="${tmp_dir}/${starter_prefix}${srv_name}"
                        pid_filename="${tmp_dir}/PID.txt"
                        log_filename="${logs_dir}/${srv_name}.log"

                        launch_service "${starter_filename}" "${log_filename}" "${srv_name}" "${pid_filename}"
                        pids[${serv_index}]=`cat "${pid_filename}"`
                    fi
                fi
            else # service not running
                clear
                echo "${srv_name} is not running. Please select:"
                echo "1 - start it"
                echo "any other key - nothing"
                read -n 1 -s action

                if [[ "${action}" = "1" ]]; then
                        echo "trying to start process..."
                        starter_filename="${tmp_dir}/${starter_prefix}${srv_name}"
                        pid_filename="${tmp_dir}/PID.txt"
                        log_filename="${logs_dir}/${srv_name}.log"

                        launch_service "${starter_filename}" "${log_filename}" "${srv_name}" "${pid_filename}"
                        pids[${serv_index}]=`cat "${pid_filename}"`

                fi
            fi
        fi
        if [ "${serv_index}" -eq "${num_of_servs}" ]; then # terminate all services and exit
            for (( idx=0; idx<${num_of_servs}; idx++ )); do
                kill -INT ${pids[idx]} >/dev/null 2>&1
            done
            break
        fi
    fi
done

echo -e "\nBye!"
cd "${current_dir}"
exit 0 

